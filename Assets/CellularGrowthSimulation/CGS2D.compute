#pragma kernel CS_InitParticles
#pragma kernel CS_EmitParticles
#pragma kernel CS_UpdateParticles
#pragma kernel CS_StoreDividableParticles
#pragma kernel CS_DivideParticles

#include "Assets/CGInc/Particles.cginc"
#include "Assets/CGInc/Random.cginc"

#define BLOCK_SIZE 512
#define THREADS [numthreads(BLOCK_SIZE, 1, 1)]

StructuredBuffer<CGS_Particle2D> _ParticlesRead;
RWStructuredBuffer<CGS_Particle2D> _Particles;
AppendStructuredBuffer<int> _ParticlePoolAppend;
ConsumeStructuredBuffer<int> _ParticlePoolConsume;

AppendStructuredBuffer<int> _DividablePoolAppend;
ConsumeStructuredBuffer<int> _DividablePoolConsume;

uint _ParticlesCount;
float _DT;

CGS_Particle2D CreateParticle2D()
{
	CGS_Particle2D p;
	p.position = float2(0, 0);
	p.velocity = float2(0, 0);
	p.radius = p.threshold = 1;
	p.links = 0;
	p.alive = true;
	return p;
}

THREADS
void CS_InitParticles(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	
	if(idx >= _ParticlesCount) return;

	CGS_Particle2D p = CreateParticle2D();
	p.alive = false;
	_Particles[idx] = p;
	_ParticlePoolAppend.Append(idx);
}

float2 _Point;
int _EmitCount;

THREADS
void CS_EmitParticles(uint3 id : SV_DispatchThreadID)
{
	if(id.x >= (uint)_EmitCount) return;

	// これきちんとブロックされるのかな？
	uint idx = _ParticlePoolConsume.Consume();

	CGS_Particle2D p = _Particles[idx];
	float2 offset = random_point_on_unit_circle(_Point + idx);
	p.position = _Point + offset;
	p.radius = hash12_sin(p.position + idx);
	p.alive = true;
	_Particles[idx] = p;
}

float _Drag;
float _Limit;
float _Repulsion;
float _Grow;

THREADS
void CS_UpdateParticles(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	if(idx >= _ParticlesCount) return;

	// パーティクルのデータを読み込み用ハッファから
	CGS_Particle2D p = _ParticlesRead[idx];

	// 活性化しているパーティクルのみを取り扱う。
	if(p.alive)
	{
		// パーティクルの成長
		p.radius = min(p.threshold, p.radius  + _DT * _Grow);

		// パーティクル同士の反発
		// ここの判定はBitonicSortに変更すれば、早くなる。どのくらい早くなるのかはわからないけど。
		for(uint i = 0; i < _ParticlesCount; ++i)
		{
			CGS_Particle2D other = _ParticlesRead[i];
			if(i == idx || !other.alive) continue;

			float2 dir = p.position - other.position;
			float l = length(dir);
			float r = (p.radius + other.radius) * _Repulsion;
			if(l < r)
			{
				p.velocity += normalize(dir) * (r - l);
			}
		}

		// 計算した速度を減衰させる。実際には自分のvelocityと相手のvelocityを見て加える力の向きは変更する必要があるだろうね。
		float2 vel = p.velocity * _DT;
		float vl = length(vel);
		if(vl > 0)
		{
			p.position += normalize(vel) * min(vl, _Limit);
			p.velocity = normalize(p.velocity) * min(_Limit, length(p.velocity) * _Drag);
		}
		else
		{
			p.velocity = float2(0, 0);
		}

		// 更新したデータを書き込み用のバッファへ
		_Particles[idx] = p;
	}
}

bool IsDividableParticle(in CGS_Particle2D p)
{
	float rate = p.radius / p.threshold;
	return rate >= 0.95;
}

uint DivideParticle(uint idx, float2 offset)
{
	CGS_Particle2D parent = _ParticlesRead[idx];
	CGS_Particle2D child = CreateParticle2D();

	// 分裂することになるので半径を半分にする。
	// つまり、質量が保存されていない。
	float hr = max(parent.radius * .5, .1);
	parent.radius = child.radius = hr;

	// 座標を調整
	float2 center = parent.position;
	parent.position = center + offset;
	child.position = center - offset;

	// 成長の限度を設定
	float x = hash12_sin(parent.position);
	child.threshold = x + hr;

	// 子を更新
	uint cidx = _ParticlePoolConsume.Consume();
	_Particles[cidx] = child;

	// 親を更新
	_Particles[idx] = parent;

	return cidx;
}

uint DivideParticle(uint idx)
{
	CGS_Particle2D parent = _ParticlesRead[idx];
	float2 offset = random_point_on_unit_circle(parent.position + idx) * parent.radius * .25;
	return DivideParticle(idx, offset);
}

THREADS
void CS_StoreDividableParticles(uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	if(idx >= _ParticlesCount) return;

	CGS_Particle2D p = _ParticlesRead[idx];
	if(p.alive && IsDividableParticle(p))
	{
		_DividablePoolAppend.Append(idx);
	}
}

uint _DivideCount;

THREADS
void CS_DivideParticles(uint3 id : SV_DispatchThreadID)
{
	// Consumeバッファの内容量はcompute側では考慮しないので、
	// CPU側で_DivideCountは調整してください。
	if(id.x >= _DivideCount) return;
	uint idx = _DividablePoolConsume.Consume();
	DivideParticle(idx);
}

THREADS
void CS_StoreDividableEdges(uint3 id : SV_DispatchThreadID)
{
	
}